# 45. 跳跃游戏 II

## 题目描述

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 
```r
示例 1:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

示例 2:

输入: [2,3,0,1,4]
输出: 2
```

提示:

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 105

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/jump-game-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码

(动态规划，贪心优化) O(n)

1. 首先定义两个指针 last 和 i，数组 f[i] 表示到达 i 所需要的最少步数。
2. 定义 last 为第一次到达 i 时上一步的位置，last 从 0 开始。
3. 根据贪心得知，令 f[i] = f[last] + 1 后，f[i] 就会是最优值。
4. 故可以根据 i 来让 last 向后移动，找到最早的可以一步到达 i 的位置，然后根据 f[last] 更新 f[i]。

时间复杂: 数组的每个元素最多被遍历两次，故时间复杂度为 O(n)。

空间复杂度:需要 O(n)

的额外空间存储数组 f。

作者：wzc1995
链接：https://www.acwing.com/solution/content/107/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n + 10];
        for(int i = 1, j = 0; i < n; i++) {
            while(j + nums[j] < i) j++;
            dp[i] = dp[j] + 1;
        }
        return dp[n - 1];
    }
}
```